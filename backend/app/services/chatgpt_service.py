from openai import OpenAI
from app.core.settings import settings
import json
import logging

logger = logging.getLogger(__name__)

class ChatGPTService:
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = "gpt-5-nano"  
    def analyze_questions(self, text: str, language: str = "vi") -> dict:
        """
        Ph√¢n t√≠ch text v√† tr√≠ch xu·∫•t c√¢u h·ªèi ƒëa d·∫°ng
        """
        try:
            logger.info(f"ü§ñ Analyzing text with ChatGPT ({len(text)} characters)...")
            
            prompt = self._build_analysis_prompt(text, language)
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert in analyzing educational content and extracting various types of questions. Always respond with valid JSON only, no additional text."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                response_format={"type": "json_object"},
            )
            
            result_text = response.choices[0].message.content
            logger.info(f"‚úÖ ChatGPT response received")
            
            # Parse JSON
            result = json.loads(result_text)
            
            logger.info(f"üìù Extracted {len(result.get('questions', []))} questions")
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå ChatGPT error: {str(e)}")
            raise Exception(f"Failed to analyze questions: {str(e)}")
    
    def _build_analysis_prompt(self, text: str, language: str) -> str:
        """Build prompt for question analysis with multiple question types"""
        
        if language == "vi":
            prompt = f"""
Ph√¢n t√≠ch vƒÉn b·∫£n sau v√† tr√≠ch xu·∫•t T·∫§T C·∫¢ c√¢u h·ªèi, h·ªó tr·ª£ NHI·ªÄU LO·∫†I c√¢u h·ªèi kh√°c nhau.

VƒÇN B·∫¢N:
{text}

Y√äU C·∫¶U:
1. T√¨m v√† tr√≠ch xu·∫•t T·∫§T C·∫¢ c√¢u h·ªèi trong vƒÉn b·∫£n
2. Nh·∫≠n di·ªán ƒê√öNG lo·∫°i c√¢u h·ªèi:
   - "multiple_choice": Tr·∫Øc nghi·ªám 1 ƒë√°p √°n ƒë√∫ng (A, B, C, D)
   - "multiple_answer": Tr·∫Øc nghi·ªám NHI·ªÄU ƒë√°p √°n ƒë√∫ng
   - "true_false": ƒê√∫ng/Sai
   - "short_answer": C√¢u h·ªèi ng·∫Øn/T·ª± lu·∫≠n
   - "fill_blank": ƒêi·ªÅn t·ª´ v√†o ch·ªó tr·ªëng
   - "ordering": S·∫Øp x·∫øp th·ª© t·ª±
3. M·ªói c√¢u h·ªèi c·∫ßn c√≥:
   - N·ªôi dung c√¢u h·ªèi ƒë·∫ßy ƒë·ªß
   - Lo·∫°i c√¢u h·ªèi ch√≠nh x√°c
   - C√°c ƒë√°p √°n (n·∫øu c√≥)
   - ƒê√°p √°n ƒë√∫ng (c√≥ th·ªÉ l√† 1 ƒë√°p √°n ho·∫∑c nhi·ªÅu ƒë√°p √°n)
   - Gi·∫£i th√≠ch (n·∫øu c√≥)
4. T·ª± ƒë·ªông s·ª≠a l·ªói ch√≠nh t·∫£ OCR

ƒê·ªäNH D·∫†NG JSON (B·∫ÆT BU·ªòC):
{{
    "exam_title": "T√™n ƒë·ªÅ thi (n·∫øu c√≥)",
    "exam_description": "M√¥ t·∫£ ng·∫Øn v·ªÅ ƒë·ªÅ thi",
    "questions": [
        {{
            "question_text": "N·ªôi dung c√¢u h·ªèi?",
            "question_type": "multiple_choice",
            "options": {{
                "A": "ƒê√°p √°n A",
                "B": "ƒê√°p √°n B",
                "C": "ƒê√°p √°n C",
                "D": "ƒê√°p √°n D"
            }},
            "correct_answer": "A",
            "explanation": "Gi·∫£i th√≠ch ƒë√°p √°n ƒë√∫ng"
        }},
        {{
            "question_text": "C√¢u h·ªèi nhi·ªÅu ƒë√°p √°n ƒë√∫ng?",
            "question_type": "multiple_answer",
            "options": {{
                "A": "ƒê√°p √°n A",
                "B": "ƒê√°p √°n B",
                "C": "ƒê√°p √°n C",
                "D": "ƒê√°p √°n D"
            }},
            "correct_answer": ["A", "C"],
            "explanation": "C·∫£ A v√† C ƒë·ªÅu ƒë√∫ng"
        }},
        {{
            "question_text": "C√¢u h·ªèi ƒë√∫ng sai?",
            "question_type": "true_false",
            "options": {{
                "A": "ƒê√∫ng",
                "B": "Sai"
            }},
            "correct_answer": "A",
            "explanation": "Gi·∫£i th√≠ch"
        }},
        {{
            "question_text": "C√¢u h·ªèi t·ª± lu·∫≠n?",
            "question_type": "short_answer",
            "options": null,
            "correct_answer": "ƒê√°p √°n m·∫´u chi ti·∫øt...",
            "explanation": "H∆∞·ªõng d·∫´n ch·∫•m ƒëi·ªÉm"
        }},
        {{
            "question_text": "ƒêi·ªÅn v√†o ch·ªó tr·ªëng: Th·ªß ƒë√¥ c·ªßa Vi·ªát Nam l√† ___",
            "question_type": "fill_blank",
            "options": null,
            "correct_answer": "H√† N·ªôi",
            "explanation": "Gi·∫£i th√≠ch"
        }},
        {{
            "question_text": "S·∫Øp x·∫øp c√°c b∆∞·ªõc sau theo ƒë√∫ng th·ª© t·ª±:",
            "question_type": "ordering",
            "options": {{
                "A": "B∆∞·ªõc 1",
                "B": "B∆∞·ªõc 2",
                "C": "B∆∞·ªõc 3"
            }},
            "correct_answer": ["C", "A", "B"],
            "explanation": "Th·ª© t·ª± ƒë√∫ng l√†: B∆∞·ªõc 3 ‚Üí B∆∞·ªõc 1 ‚Üí B∆∞·ªõc 2"
        }}
    ]
}}

L∆ØU √ù QUAN TR·ªåNG:
- Nh·∫≠n di·ªán CH√çNH X√ÅC lo·∫°i c√¢u h·ªèi d·ª±a tr√™n n·ªôi dung
- N·∫øu c√¢u h·ªèi c√≥ nhi·ªÅu ƒë√°p √°n ƒë√∫ng ‚Üí d√πng "multiple_answer" v·ªõi correct_answer l√† array
- N·∫øu c√¢u h·ªèi y√™u c·∫ßu s·∫Øp x·∫øp ‚Üí d√πng "ordering" v·ªõi correct_answer l√† array th·ª© t·ª± ƒë√∫ng
- N·∫øu c√¢u h·ªèi t·ª± lu·∫≠n/ng·∫Øn ‚Üí d√πng "short_answer" v·ªõi options = null
- N·∫øu kh√¥ng t√¨m th·∫•y c√¢u h·ªèi ‚Üí tr·∫£ v·ªÅ "questions": []
- Ch·ªâ tr·∫£ v·ªÅ JSON, KH√îNG th√™m text gi·∫£i th√≠ch
"""
        else:  # English
            prompt = f"""
Analyze the following text and extract ALL questions, supporting MULTIPLE question types.

TEXT:
{text}

REQUIREMENTS:
1. Find and extract ALL questions in the text
2. Correctly identify question type:
   - "multiple_choice": Single correct answer (A, B, C, D)
   - "multiple_answer": Multiple correct answers
   - "true_false": True/False
   - "short_answer": Short answer/Essay
   - "fill_blank": Fill in the blank
   - "ordering": Arrange in order
3. Each question should have:
   - Complete question text
   - Correct question type
   - Options (if applicable)
   - Correct answer (single or multiple)
   - Explanation (if available)
4. Automatically fix OCR spelling errors

JSON FORMAT (REQUIRED):
{{
    "exam_title": "Exam title (if any)",
    "exam_description": "Brief description",
    "questions": [
        {{
            "question_text": "Question text?",
            "question_type": "multiple_choice",
            "options": {{"A": "...", "B": "...", "C": "...", "D": "..."}},
            "correct_answer": "A",
            "explanation": "Explanation"
        }},
        {{
            "question_text": "Multiple answer question?",
            "question_type": "multiple_answer",
            "options": {{"A": "...", "B": "...", "C": "...", "D": "..."}},
            "correct_answer": ["A", "C"],
            "explanation": "Both A and C are correct"
        }},
        {{
            "question_text": "Essay question?",
            "question_type": "short_answer",
            "options": null,
            "correct_answer": "Sample answer...",
            "explanation": "Grading rubric"
        }}
    ]
}}

IMPORTANT NOTES:
- Correctly identify question type based on content
- For multiple correct answers ‚Üí use "multiple_answer" with array correct_answer
- For ordering questions ‚Üí use "ordering" with correct order array
- For essay/short answer ‚Üí use "short_answer" with options = null
- If no questions found ‚Üí return "questions": []
- Return ONLY JSON, no additional text
"""
        
        return prompt
    
    # C√°c method kh√°c gi·ªØ nguy√™n...
    def generate_similar_questions(self, question: str, count: int = 3) -> list:
        """
        T·∫°o c√°c c√¢u h·ªèi t∆∞∆°ng t·ª±
        """
        try:
            logger.info(f"ü§ñ Generating {count} similar questions...")
            
            prompt = f"""
D·ª±a tr√™n c√¢u h·ªèi sau, h√£y t·∫°o {count} c√¢u h·ªèi t∆∞∆°ng t·ª± (c√πng ch·ªß ƒë·ªÅ, kh√°c n·ªôi dung):

C√ÇU H·ªéI G·ªêC:
{question}

Y√äU C·∫¶U:
- T·∫°o {count} c√¢u h·ªèi m·ªõi, kh√°c nhau
- Gi·ªØ nguy√™n ƒë·ªô kh√≥
- C√πng ƒë·ªãnh d·∫°ng tr·∫Øc nghi·ªám
- C√≥ ƒë√°p √°n ƒë√∫ng r√µ r√†ng

ƒê·ªäNH D·∫†NG JSON:
{{
    "questions": [
        {{
            "question_text": "C√¢u h·ªèi m·ªõi?",
            "options": {{"A": "...", "B": "...", "C": "...", "D": "..."}},
            "correct_answer": "A",
            "explanation": "Gi·∫£i th√≠ch"
        }}
    ]
}}
"""
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are an expert question generator. Return valid JSON only."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            return result.get("questions", [])
            
        except Exception as e:
            logger.error(f"‚ùå Generate questions error: {str(e)}")
            return []
    
    def grade_essay(self, question: str, student_answer: str, correct_answer: str) -> dict:
        """
        Ch·∫•m b√†i t·ª± lu·∫≠n b·∫±ng AI
        
        Returns:
            {
                "score": 8.5,  # ƒêi·ªÉm (0-10)
                "feedback": "Nh·∫≠n x√©t chi ti·∫øt...",
                "strengths": ["ƒêi·ªÉm m·∫°nh 1", "ƒêi·ªÉm m·∫°nh 2"],
                "improvements": ["C·∫ßn c·∫£i thi·ªán 1", "C·∫ßn c·∫£i thi·ªán 2"]
            }
        """
        try:
            logger.info(f"ü§ñ Grading essay answer...")
            
            prompt = f"""
Ch·∫•m ƒëi·ªÉm c√¢u tr·∫£ l·ªùi t·ª± lu·∫≠n sau:

C√ÇU H·ªéI:
{question}

ƒê√ÅP √ÅN CHU·∫®N:
{correct_answer}

C√ÇU TR·∫¢ L·ªúI C·ª¶A H·ªåC SINH:
{student_answer}

Y√äU C·∫¶U:
1. Ch·∫•m ƒëi·ªÉm t·ª´ 0-10
2. ƒê∆∞a ra nh·∫≠n x√©t chi ti·∫øt
3. N√™u ƒëi·ªÉm m·∫°nh
4. N√™u ƒëi·ªÉm c·∫ßn c·∫£i thi·ªán

ƒê·ªäNH D·∫†NG JSON:
{{
    "score": 8.5,
    "feedback": "Nh·∫≠n x√©t t·ªïng quan v·ªÅ b√†i l√†m...",
    "strengths": ["ƒêi·ªÉm m·∫°nh 1", "ƒêi·ªÉm m·∫°nh 2"],
    "improvements": ["C·∫ßn c·∫£i thi·ªán 1", "C·∫ßn c·∫£i thi·ªán 2"]
}}
"""
            
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are an expert teacher. Grade fairly and provide constructive feedback. Return valid JSON only."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            logger.info(f"‚úÖ Essay graded: {result['score']}/10")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Essay grading error: {str(e)}")
            return {
                "score": 0,
                "feedback": "Kh√¥ng th·ªÉ ch·∫•m ƒëi·ªÉm",
                "strengths": [],
                "improvements": []
            }

# Singleton instance
chatgpt_service = ChatGPTService()